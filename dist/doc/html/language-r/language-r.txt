-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A package for parsing and compiling R/Splus code.
--   
--   Language-R aims to provide a means for compiling Splus/R source code
--   to executable machine code.
@package language-r
@version 0.1.2


-- | Created : 05<i>28</i>10
--   
--   Description : Core level internal definitions.
module Language.R.Internal

-- | Parsing is performed using a two-pass lexer - parser sequence to
--   generate an abstract syntax tree. This allows disambiguation and
--   proper handling of peculiarities of the R language.
type Token = (SourcePos, Tok)

-- | The LexState is simply the list of all processed tokens.
type LexState = [Tok]

-- | On first pass, tokens are identified without any lookahead based on
--   context alone.
data Tok

-- | String literal
StrTok :: String -> Tok

-- | Numeric literal (as a string)
NumTok :: String -> Tok

-- | Textual atom (keyword, identifier, etc)
AtmTok :: String -> Tok

-- | Non-alphanumeric character
SymTok :: String -> Tok

-- | Complete comment
ComTok :: String -> Tok

-- | TODO: This should be specified better
whiteSpace :: ParsecT String u Identity ()
instance Eq Tok
instance Ord Tok
instance Show Tok


-- | Created : 05<i>28</i>10
--   
--   Description : DESCRIPTION HERE.
module Language.R.Evaluate


-- | Created : 06<i>11</i>10
--   
--   Description : DESCRIPTION HERE.
module Language.R.SrcLocation

-- | TODO: This is primarily inspired / stolen from language-python
--   Furthermore, this is not how I want to do this, this is not where this
--   code belongs, and this is not a fully functional implementation,
--   merely a stub.
--   
--   A location for a syntactic entity from the source code. The location
--   is specified by its filename, and starting row and column.
data SrcLocation
Sloc :: String -> Int -> Int -> SrcLocation
sloc_filename :: SrcLocation -> String
sloc_row :: SrcLocation -> Int
sloc_column :: SrcLocation -> Int
NoLocation :: SrcLocation
srcPosToLocation :: SourcePos -> SrcLocation

-- | Types which have a span.
class Span a
getSpan :: (Span a) => a -> SrcSpan

-- | Create a new span which encloses two spanned things.
spanning :: (Span a, Span b) => a -> b -> SrcSpan

-- | Source location spanning a contiguous section of a file.
data SrcSpan

-- | A span which starts and ends on the same line.
SpanCoLinear :: !String -> !!Int -> !!Int -> !!Int -> SrcSpan
span_filename :: SrcSpan -> !String
span_row :: SrcSpan -> !!Int
span_start_column :: SrcSpan -> !!Int
span_end_column :: SrcSpan -> !!Int

-- | A span which starts and ends on different lines.
SpanMultiLine :: !String -> !!Int -> !!Int -> !!Int -> !!Int -> SrcSpan
span_filename :: SrcSpan -> !String
span_start_row :: SrcSpan -> !!Int
span_start_column :: SrcSpan -> !!Int
span_end_row :: SrcSpan -> !!Int
span_end_column :: SrcSpan -> !!Int

-- | A span which is actually just one point in the file.
SpanPoint :: !String -> !!Int -> !!Int -> SrcSpan
span_filename :: SrcSpan -> !String
span_row :: SrcSpan -> !!Int
span_column :: SrcSpan -> !!Int

-- | No span information.
SpanEmpty :: SrcSpan

-- | Make a point span from the start of a span
spanStartPoint :: SrcSpan -> SrcSpan

-- | Make a span from two locations. Assumption: either the arguments are
--   the same, or the left one preceeds the right one.
mkSrcSpan :: SrcLocation -> SrcLocation -> SrcSpan
mkSrcSpan' :: SourcePos -> SourcePos -> SrcSpan

-- | Combines two <a>SrcSpan</a> into one that spans at least all the
--   characters within both spans. Assumes the <a>file</a> part is the same
--   in both inputs
combineSrcSpans :: SrcSpan -> SrcSpan -> SrcSpan

-- | Get the row of the start of a span.
startRow :: SrcSpan -> Int

-- | Get the row of the end of a span.
endRow :: SrcSpan -> Int

-- | Get the column of the start of a span.
startCol :: SrcSpan -> Int

-- | Get the column of the end of a span.
endCol :: SrcSpan -> Int
instance Typeable SrcSpan
instance Typeable SrcLocation
instance Eq SrcSpan
instance Ord SrcSpan
instance Show SrcSpan
instance Data SrcSpan
instance Eq SrcLocation
instance Ord SrcLocation
instance Show SrcLocation
instance Data SrcLocation
instance Span SrcLocation
instance Span SrcSpan
instance (Span a, Span b) => Span (a, b)
instance (Span a, Span b) => Span (Either a b)
instance (Span a) => Span (Maybe a)
instance (Span a) => Span [a]


-- | Created : 05<i>28</i>10
--   
--   Description : Necessary Token definitions for parsing the Splus / R
--   Language.
module Language.R.Token
data SpecialConstant
NA :: SpecialConstant
NaN :: SpecialConstant
NULL :: SpecialConstant
Inf :: SpecialConstant
TRUE :: SpecialConstant
FALSE :: SpecialConstant
NA_integer_ :: SpecialConstant
NA_real_ :: SpecialConstant
NA_complex_ :: SpecialConstant
NA_character_ :: SpecialConstant

-- | Lexical Tokens
data Token
SpaceToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan
NewlineToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan
TabToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan
CommentToken :: SrcSpan -> String -> Token
token_span :: Token -> SrcSpan
token_literal :: Token -> String
StringToken :: SrcSpan -> String -> Token
token_span :: Token -> SrcSpan
token_literal :: Token -> String
NumericToken :: SrcSpan -> String -> Double -> Token
token_span :: Token -> SrcSpan
token_literal :: Token -> String
token_num :: Token -> Double
LogicalToken :: SrcSpan -> String -> Bool -> Token
token_span :: Token -> SrcSpan
token_literal :: Token -> String
token_logical :: Token -> Bool
IntegerToken :: SrcSpan -> String -> Integer -> Token
token_span :: Token -> SrcSpan
token_literal :: Token -> String
token_int :: Token -> Integer
ComplexToken :: SrcSpan -> String -> (Double, Double) -> Token
token_span :: Token -> SrcSpan
token_literal :: Token -> String
token_comp :: Token -> (Double, Double)
SpecialConstantToken :: SrcSpan -> String -> SpecialConstant -> Token
token_span :: Token -> SrcSpan
token_literal :: Token -> String
token_special :: Token -> SpecialConstant
IdentifierToken :: SrcSpan -> String -> Token
token_span :: Token -> SrcSpan
token_literal :: Token -> String

-- | Keyword: 'if'
IfToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'for'
ForToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'while'
WhileToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'repeat'
RepeatToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'return'
ReturnToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'function'
FunctionToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'quote'
QuoteToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'switch'
SwitchToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'break'
BreakToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'next'
NextToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan
ErrorToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '%*%'
MatrixMultiplyToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '%/%'
MatrixDivideToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '%in%'
IntersectToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '%o%'
OuterProductToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '%x%'
KroneckerProductToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan
CustomSpecialOpToken :: SrcSpan -> String -> Token
token_span :: Token -> SrcSpan
token_literal :: Token -> String

-- | Keyword: 'abs'
AbsToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'sign'
SignToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'sqrt'
SqrtToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'floor'
FloorToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'ceiling'
CeilingToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'exp'
ExpToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'expm1'
Expm1Token :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'log2'
Log2Token :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'log10'
Log10Token :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'log1p'
Log1pToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'cos'
CosToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'sin'
SinToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'tan'
TanToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'acos'
AcosToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'asin'
AsinToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'atan'
AtanToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'cosh'
CoshToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'sinh'
SinhToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'tanh'
TanhToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'acosh'
AcoshToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'asinh'
AsinhToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'atanh'
AtanhToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'gamma'
GammaToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'lgamma'
LgammaToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'digamma'
DigammaToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'trigamma'
TrigammaToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'cumsum'
CumsumToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'cumprod'
CumprodToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'cummax'
CummaxToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'cummin'
CumminToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'Im'
ImToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'Re'
ReToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'Arg'
ArgToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'Conj'
ConjToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'Mod' Metaprogramming / Language
ModToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'length'
LengthToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'length&lt;-'
LengthAssignToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'class'
ClassToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'class&lt;-'
ClassAssignToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'oldClass'
OldClassToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'oldCLass&lt;-'
OldCLassAssignToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'attr'
AttrToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'attr&lt;-'
AttrAssignToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'attributes'
AttributesToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'attributes&lt;-'
AttributesAssignToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'names'
NamesToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'names&lt;-'
NamesAssignToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'dim'
DimToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'dim&lt;-'
DimAssignToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'dimnames'
DimnamesToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'dimnames&lt;-'
DimnamesAssignToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'levels&lt;-'
LevelsAssignToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'environment&lt;-'
EnvironmentAssignToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Keyword: 'storage.mode&lt;-'
StorageModeAssignToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Symbol: ';'
SemicolonToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Symbol: ','
CommaToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Symbol: '('
ParenLeftToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Symbol: ')'
ParenRightToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Symbol: '{'
BraceLeftToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Symbol: '}'
BraceRightToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Symbol: '['
BracketLeftToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Symbol: ']'
BracketRightToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Symbol: '...'
ThreeDotsToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Symbol: ':'
ColonToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Symbol: ':::'
DoubleColonToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Symbol: '?'
QuestionMarkToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Symbol: '??'
DoubleQMarkToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '%%'
ModulusToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '@'
SlotOperator :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '+'
PlusToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '!'
NegateToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '&lt;-'
AssignLeftToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '-&gt;'
AssignRightToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '&lt;&lt;-'
AssignLeftToken' :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '='
EqualsToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '[&lt;-'
SliceReplaceToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '[[&lt;-'
MemberReplaceToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '$&lt;-'
MemberReplaceToken' :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '-'
MinusToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '*'
MultiplyToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '/'
DivideToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '^'
ExponentToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '&lt;'
LessToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '&lt;='
LessEqualToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '=='
EqualityToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '!='
InequalityToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '&gt;='
GreatEqualToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '&gt;'
GreatToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '|'
ElementwiseOrToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '||'
VectorOrToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '&amp;'
ElementwiseAndToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '&amp;&amp;'
VectorAndToken :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '['
SliceOperator :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '[['
MemberOperator :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | Operator: '$'
MemberOperator' :: SrcSpan -> Token
token_span :: Token -> SrcSpan

-- | TODO: These two data declartions need to go somewhere else Numeric
--   types
data RNumType
RNumType :: String -> RVectorMode -> RNumType
num_typeof :: RNumType -> String
num_vecmode :: RNumType -> RVectorMode

-- | There are six types of vector storage in R
data RVectorMode
VecLogical :: Bool -> RVectorMode
VecNumericInt :: Integer -> RVectorMode
VecNumeric :: Double -> RVectorMode
VecComplex :: (Double, Double) -> RVectorMode
VecCharacter :: Char -> RVectorMode
VecRaw :: String -> RVectorMode

-- | Classification of tokens
data TokenClass
Comment :: TokenClass
Value :: TokenClass
Identifier :: TokenClass
Punctuation :: TokenClass
Bracket :: TokenClass
Keyword :: TokenClass
String :: TokenClass
Operator :: TokenClass
Assignment :: TokenClass
Replacement :: TokenClass
Builtin :: TokenClass
classifyToken :: Token -> TokenClass

-- | Produce a string from a token
tokenString :: Token -> String
operatorMap :: Map String (SrcSpan -> Token)
punctMap :: Map String (SrcSpan -> Token)
reservedMap :: Map String (SrcSpan -> Token)
builtinsMap :: Map String (SrcSpan -> Token)
instance Show TokenClass
instance Eq TokenClass
instance Ord TokenClass
instance Read RVectorMode
instance Ord RVectorMode
instance Eq RVectorMode
instance Show RVectorMode
instance Read RNumType
instance Ord RNumType
instance Eq RNumType
instance Show RNumType
instance Show Token
instance Ord Token
instance Eq Token
instance Read SpecialConstant
instance Show SpecialConstant
instance Eq SpecialConstant
instance Ord SpecialConstant


-- | Created : 05<i>28</i>10
--   
--   Description : Representation of the R Abstract Syntax Tree.
module Language.R.AST

-- | Convenient access to annotations in annotated types.
class Annotated t
annot :: (Annotated t) => t annot -> annot

-- | Identifier.
data Ident annot
Ident :: String -> annot -> Ident annot
ident_string :: Ident annot -> String
ident_annot :: Ident annot -> annot
type IdentSpan = Ident SrcSpan

-- | A block of statements. A suite is a group of statements controlled by
--   a clause, for example, the body of a loop.
type Suite annot = [Statement annot]
type SuiteSpan = Suite SrcSpan
data Statement annot

-- | While loop.
While :: Expr annot -> Suite annot -> annot -> Statement annot

-- | Loop condition.
while_cond :: Statement annot -> Expr annot

-- | Loop body.
while_body :: Statement annot -> Suite annot
stmt_annot :: Statement annot -> annot

-- | For loop.
For :: Ident annot -> Expr annot -> Suite annot -> annot -> Statement annot

-- | Loop variables.
for_target :: Statement annot -> Ident annot

-- | Loop generator.
for_values :: Statement annot -> Expr annot

-- | Loop body
for_body :: Statement annot -> Suite annot
stmt_annot :: Statement annot -> annot

-- | Conditional statement (if-elif-else).
Conditional :: [(Expr annot, Suite annot)] -> Suite annot -> annot -> Statement annot

-- | Sequence of if-elif
cond_guards :: Statement annot -> [(Expr annot, Suite annot)]

-- | Possibly empty unconditional else clause.
cond_else :: Statement annot -> Suite annot
stmt_annot :: Statement annot -> annot

-- | Assignment statement.
Assign :: Ident annot -> Expr annot -> annot -> Statement annot

-- | Entity to assign to.
assign_to :: Statement annot -> Ident annot

-- | Expression to evaluate.
assign_expr :: Statement annot -> Expr annot
stmt_annot :: Statement annot -> annot

-- | Return statement
Return :: Maybe (Expr annot) -> annot -> Statement annot
return_expr :: Statement annot -> Maybe (Expr annot)
stmt_annot :: Statement annot -> annot

-- | Break statement
Break :: annot -> Statement annot
stmt_annot :: Statement annot -> annot

-- | Continue statement
Continue :: annot -> Statement annot
stmt_annot :: Statement annot -> annot

-- | Repeat statment
Repeat :: Expr annot -> annot -> Statement annot
repeat_expr :: Statement annot -> Expr annot
stmt_annot :: Statement annot -> annot

-- | Switch statement
Switch :: [(Expr annot, Suite annot)] -> annot -> Statement annot
switch_guards :: Statement annot -> [(Expr annot, Suite annot)]
stmt_annot :: Statement annot -> annot

-- | Expression statement.
StmtExpr :: Expr annot -> annot -> Statement annot
stmt_expr :: Statement annot -> Expr annot
stmt_annot :: Statement annot -> annot

-- | Print statement.
Print :: [Expr annot] -> annot -> Statement annot

-- | Arguments to print
print_exprs :: Statement annot -> [Expr annot]
stmt_annot :: Statement annot -> annot

-- | Exec statement. <i>Version 2 only</i>.
Exec :: Expr annot -> Maybe (Expr annot, Maybe (Expr annot)) -> annot -> Statement annot

-- | Expression to exec.
exec_expr :: Statement annot -> Expr annot
exec_globals_locals :: Statement annot -> Maybe (Expr annot, Maybe (Expr annot))
stmt_annot :: Statement annot -> annot

-- | Function definition.
Fun :: Ident annot -> Maybe (Expr annot) -> Suite annot -> annot -> Statement annot

-- | Function name. , fun_args :: [Parameter annot] -- ^ Function parameter
--   list.
fun_name :: Statement annot -> Ident annot

-- | Optional result annotation.
fun_result_annot :: Statement annot -> Maybe (Expr annot)

-- | Function body.
fun_body :: Statement annot -> Suite annot
stmt_annot :: Statement annot -> annot
type StatementSpan = Statement SrcSpan
data Expr annot

-- | Variable.
Var :: Ident annot -> annot -> Expr annot
var_ident :: Expr annot -> Ident annot
expr_annot :: Expr annot -> annot

-- | Literal numerical
Num :: Double -> String -> annot -> Expr annot
num_value :: Expr annot -> Double
expr_literal :: Expr annot -> String
expr_annot :: Expr annot -> annot

-- | Literal logical
Bool :: Bool -> annot -> Expr annot
logical_value :: Expr annot -> Bool
expr_annot :: Expr annot -> annot

-- | Literal 'NULL' value.
Null :: annot -> Expr annot
expr_annot :: Expr annot -> annot

-- | Literal 'NaN' value.
NaN :: annot -> Expr annot
expr_annot :: Expr annot -> annot

-- | Literal 'NA' value.
NA :: annot -> Expr annot
expr_annot :: Expr annot -> annot

-- | Literal raw
ByteStrings :: [String] -> annot -> Expr annot
byte_string_strings :: Expr annot -> [String]
expr_annot :: Expr annot -> annot

-- | Literal character
Char :: String -> annot -> Expr annot
strings_strings :: Expr annot -> String
expr_annot :: Expr annot -> annot

-- | Function call.
Call :: Ident annot -> annot -> Expr annot
call_fun :: Expr annot -> Ident annot
expr_annot :: Expr annot -> annot
instance Typeable1 Expr
instance Typeable1 Statement
instance Typeable1 Ident
instance (Eq annot) => Eq (Expr annot)
instance (Ord annot) => Ord (Expr annot)
instance (Show annot) => Show (Expr annot)
instance (Data annot) => Data (Expr annot)
instance (Eq annot) => Eq (Statement annot)
instance (Ord annot) => Ord (Statement annot)
instance (Show annot) => Show (Statement annot)
instance (Data annot) => Data (Statement annot)
instance (Eq annot) => Eq (Ident annot)
instance (Ord annot) => Ord (Ident annot)
instance (Show annot) => Show (Ident annot)
instance (Data annot) => Data (Ident annot)
instance Annotated Statement
instance Span StatementSpan
instance Annotated Ident
instance Span IdentSpan


-- | Created : 05<i>28</i>10
--   
--   Description : DESCRIPTION HERE.
module Language.R.Generator
data Tok

-- | An <tt>identifier</tt> i.e. variable
RIdent :: TokType -> String -> Tok

-- | An <tt>operator</tt> i.e. symbolic function name
ROper :: TokType -> String -> Tok

-- | All numbers are of type double
RNumConst :: TokType -> Double -> Tok

-- | A *punctuation* type character
RSymb :: TokType -> String -> Tok

-- | A literal <tt>String</tt>
RString :: TokType -> String -> Tok

-- | A complete comment
RComment :: TokType -> String -> Tok

-- | Objects of type <tt>TokType</tt> represent the result of the first
--   (lexing) pass of the input text. <tt>TokType</tt>s are identified
--   without any lookahead or backtracing of the input.
data TokType
Variable :: TokType
Reserved :: TokType
Oprator :: TokType
Bltin :: TokType
Primitive :: TokType
Strng :: TokType
Intgr :: TokType
Dble :: TokType
CtrlFl :: TokType
Grouping :: TokType
Logical :: TokType
Closure :: TokType
Cmmnt :: TokType

-- | <tt>Token</tt>s are <tt>Tok</tt>s with the metadata of
--   <tt>SourcePos</tt>
type TToken = (Tok, SourcePos)

-- | Objects of <tt>TokSt</tt> are used to store the <tt>Token</tt> stack
--   during first pass lexing.
type TokSt = [Tok]

-- | Reserved operations which cannot be overwritten and require
--   rearrangement during the second pass.
data R_ResOp
BinMinus :: R_ResOp
BinPlus :: R_ResOp
UnNot :: R_ResOp
UnBinTilde :: R_ResOp
UnHelp :: R_ResOp
BinSeq :: R_ResOp
BinMult :: R_ResOp
BinDiv :: R_ResOp
BinExp :: R_ResOp
BinUndef :: R_ResOp
BinMod :: R_ResOp
BinIntDiv :: R_ResOp
BinMatMult :: R_ResOp
BinOutPr :: R_ResOp
BinKronPr :: R_ResOp
BinIntrsct :: R_ResOp
BinLT :: R_ResOp
BinGT :: R_ResOp
BinEQ :: R_ResOp
BinGE :: R_ResOp
BinLE :: R_ResOp
BinVecAnd :: R_ResOp
BinAnd :: R_ResOp
BinVecOr :: R_ResOp
BinOr :: R_ResOp
BinAsnLeft :: R_ResOp
BinAsnRight :: R_ResOp
BinElmnt :: R_ResOp
BinMemAsn :: R_ResOp
BinSlot :: R_ResOp
BinElemnt :: R_ResOp
BinElemntAsn :: R_ResOp
BinIndxAsn :: R_ResOp
BinEql :: R_ResOp
BinIndx :: R_ResOp

-- | R *builtin* functions which cannot be overwritten and are not
--   expressed
data R_Builtin

-- | Mathematical functions
R_MathFn :: R_Builtin

-- | Language / programming functions
R_PrgFn :: R_Builtin

-- | Debugging functions
R_DbgFn :: R_Builtin

-- | Special syntax assignment functions
R_AsnFn :: R_Builtin

-- | Functions taking arbitrary length argument lists
R_nArgEff :: R_Builtin

-- | Control flow functions
R_CtrlFlow :: R_Builtin
rResOps :: [(R_ResOp, String)]
resOps :: Map R_ResOp String
rFuncPrims :: [(String, R_Builtin)]
funcPrims :: Map String R_Builtin
rStyle :: LanguageDef st
rlang :: TokenParser st
lexSpecialConstant :: ParsecT String u Identity Token
lexComment :: ParsecT String u Identity Token
lexInteger :: ParsecT String u Identity Token
lexNumeric :: ParsecT String u Identity Token
lexComplex :: ParsecT String u Identity Token
lexLogical :: ParsecT String u Identity Token
lexString :: ParsecT String u Identity Token
lexOperator :: ParsecT String u Identity Token
lexReserved :: ParsecT String u Identity Token
dblQuotedString :: (Stream s m Char) => ParsecT s u m String
singQuotedString :: (Stream s m Char) => ParsecT s u m String
quotedString :: (Stream s m Char) => ParsecT s u m String
instance Read R_Builtin
instance Show R_Builtin
instance Eq R_Builtin
instance Ord R_Builtin
instance Enum R_Builtin
instance Read R_ResOp
instance Ord R_ResOp
instance Show R_ResOp
instance Eq R_ResOp
instance Enum R_ResOp
instance Read TokType
instance Eq TokType
instance Ord TokType
instance Read Tok
instance Eq Tok
instance Ord Tok
instance Show Tok
instance Show TokType


-- | Created : 05<i>28</i>10
--   
--   Description : This module contains the functions used for lexing an
--   list of strings (representing either source code lines or interactive
--   input) into a stack of tokens.
module Language.R.Lexer


-- | Created : 05<i>28</i>10
--   
--   Description : DESCRIPTION HERE.
module Language.R.Parser

-- | Data structures for describing the AST.
--   
--   Valid range for a lexically scoped variable. TODO: This really should
--   be implemented using a frame stack.
data Scope

-- | End of scope / GC okay
Scope :: SourcePos -> SourcePos -> Scope

-- | Start of scope
sStart :: Scope -> SourcePos
sEnd :: Scope -> SourcePos

-- | All numeric data types in R are actually represented as doubles; all R
--   atomic datatypes are actually vectors.
data RNumeric
RNumeric :: [Double] -> Maybe [String] -> String -> Scope -> RNumType -> RNumeric

-- | Values
rnVals :: RNumeric -> [Double]

-- | Name vector
rnNames :: RNumeric -> Maybe [String]

-- | Bound symbol
rnIdent :: RNumeric -> String

-- | Valid scope
rnScope :: RNumeric -> Scope

-- | Type as displayed by R
rnAlias :: RNumeric -> RNumType

-- | Numeric variables in R can be declared as numeric() or integer()
data RNumType
NumTypeInteger :: RNumType
NumTypeNumeric :: RNumType

-- | Character Vector
data RCharacter
RCharacter :: [String] -> Maybe [String] -> String -> Scope -> RCharacter
rcVals :: RCharacter -> [String]
rcNames :: RCharacter -> Maybe [String]
rcIdent :: RCharacter -> String
rcScope :: RCharacter -> Scope

-- | Boolean Vector
data RBoolean
RBoolean :: [Bool] -> Maybe [String] -> String -> Scope -> RBoolean
rbVals :: RBoolean -> [Bool]
rbNames :: RBoolean -> Maybe [String]
rbIdent :: RBoolean -> String
rbScope :: RBoolean -> Scope

-- | In general, and R Vector must be one of the following.
data RVector
VNumeric :: RNumeric -> RVector
VCharacter :: RCharacter -> RVector
VBool :: RBoolean -> RVector
data RList
RList :: [RObject] -> Maybe [String] -> Scope -> String -> RList
rlCols :: RList -> [RObject]
rlNames :: RList -> Maybe [String]
rlScope :: RList -> Scope
rlIdent :: RList -> String
data RObject
OList :: RList -> RObject
OBoolean :: RBoolean -> RObject
OCharacter :: RCharacter -> RObject
ONumeric :: RNumeric -> RObject
instance Eq RObject
instance Ord RObject
instance Show RObject
instance Eq RList
instance Ord RList
instance Show RList
instance Eq RVector
instance Ord RVector
instance Show RVector
instance Eq RBoolean
instance Ord RBoolean
instance Show RBoolean
instance Eq RCharacter
instance Ord RCharacter
instance Show RCharacter
instance Show RNumType
instance Ord RNumType
instance Eq RNumType
instance Enum RNumType
instance Eq RNumeric
instance Ord RNumeric
instance Show RNumeric
instance Eq Scope
instance Ord Scope
instance Show Scope
